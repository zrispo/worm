<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>50 C. Elegans in a Blender</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin:0;
            padding:0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src="libs/Three.js"></script>
    <script src="libs/Detector.js"></script>
    <script src="libs/cannon.js"></script>
    <script src="worm/mind/connectome.js"></script>
    <script src="util.js"></script>

    <script>

    var world;
    var dt = 1 / 60;
    function initCannon(){
        // Setup our world
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        world.gravity.set(0,-10,0);
        world.broadphase = new CANNON.NaiveBroadphase();
    }

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
    var camera, scene, renderer;
    var time = Date.now();
    var container;
    function initThree() {

        projector = new THREE.Projector();

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0xFFFFFF, 500, 10000 );

        // camera
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.5, 10000 );
        var cp = 12;
        camera.position.set(-cp, cp, cp);
        camera.lookAt(new THREE.Vector3(0,0,0));
        scene.add(camera);

        // lights
        var light, materials;
        scene.add( new THREE.AmbientLight( 0x333333 ) );

        light = new THREE.DirectionalLight( 0xffffff, 1.0 );
        var d = 20;
        light.position.set( -d, d, d/5 );
        light.castShadow = true;
        //light.shadowCameraVisible = true;

        light.shadowMapWidth = 1024;
        light.shadowMapHeight = 1024;

        light.shadowCameraLeft = -d;
        light.shadowCameraRight = d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;

        light.shadowCameraFar = 3*d;
        light.shadowCameraNear = d;
        light.shadowDarkness = 0.5;

        scene.add( light );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( scene.fog.color );

        container.appendChild( renderer.domElement );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.shadowMapEnabled = true;

        window.addEventListener('resize', onWindowResize, false );
        window.addEventListener("mousedown", onMouseDown, false );
    }

    var worms = [];
    var nSegments = 9;
    var nWorms = 20;
    function initWorm() {

        var numWormMeshesAdded = 0;
        for(var wormCounter=0; wormCounter<nWorms; wormCounter++){

            var newWorm = {};
            newWorm.brain = new Brain();
            newWorm.brain.setup();
            newWorm.wormVelocityX = 0;
            newWorm.wormVelocityY = 0;
            newWorm.noseTouchTimer = 0;
            newWorm.sniffTimer = 0;

            var wormHitboxHeight = 0.1;
            var wormHitboxWidth = 0.3;
            var mass = 1;
            var gap = 0.2;
            var last = null;

            newWorm.wormSegments=[];
            for(var i=0; i<nSegments; i++){

                var width = wormHitboxWidth;
                var boxShape = new CANNON.Box(new CANNON.Vec3(width, width, wormHitboxHeight));
                //var boxShape = new CANNON.Sphere(width);
                boxBody = new CANNON.Body({ mass: 1 });
                boxBody.addShape(boxShape);
                boxBody.position.set(0, 1.6 + wormCounter, -0.5 - wormHitboxHeight*i - gap*i);
                world.addBody(boxBody);
                newWorm.wormSegments.push(boxBody);

                if(last) {
                    var c = new CANNON.LockConstraint(boxBody, last);
                    world.addConstraint(c);
                }
                last = boxBody;
            }

            worms.push(newWorm);

            loader = new THREE.JSONLoader();
            loader.load( 'worm/body/worm.json', function( geometry,  materials ){

                materials[0].skinning = true;

                var cs = 1.0;
                
                var wormMesh = new THREE.SkinnedMesh( geometry, new THREE.MeshFaceMaterial(materials) );
                wormMesh.position.set(0,0,0);
                wormMesh.scale.set (cs, cs, cs);
                wormMesh.castShadow = true;
                wormMesh.receiveShadow = false;

                wormMesh.isWorm = true;
                wormMesh.wormID = numWormMeshesAdded;
                numWormMeshesAdded ++;

                scene.add(wormMesh);

            } );
        }
    }

    function addObjectToScene(path, name) {
        loader = new THREE.JSONLoader();
        loader.load( path, function(geometry,  materials) {

            var newObject = new THREE.Mesh( geometry, materials[0] );
            //var m = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );
            newObject.position.set(0,0,0);
            newObject.scale.set (1,1,1);
            newObject.castShadow = true;
            newObject.receiveShadow = true;
            newObject.objectName = name;

            scene.add(newObject);

        } );
    }

    function addPhysicsObjectToScene(name, hbx, hby, hbz, px, py, pz, mass) {
        var shape = new CANNON.Box(new CANNON.Vec3(hbx, hby, hbz));
        var body = new CANNON.Body({ mass: mass });
        body.addShape(shape);
        body.position.set(px, py, pz);
        body.objectName = name;
        world.addBody(body);
    }

    function onMouseDown(e){

        for(var i = 0; i < world.bodies.length; i++) {
            if(world.bodies[i].mass != 0) {
                var shakePower = 5;
                world.bodies[i].velocity.x += Math.random()*shakePower*2-shakePower;
                world.bodies[i].velocity.y += shakePower;
                world.bodies[i].velocity.z += Math.random()*shakePower*2-shakePower;
            }
        }

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );
        updateWorm();
        updatePhysics();
        render();
    }

    var lastTime = Date.now();
    var brainToUpdate = 0;
    function updateWorm() {

        var updateBrains = false;

        var currTime = Date.now();
        if(currTime - lastTime > 300/nWorms) {
            brainToUpdate++;
            if(brainToUpdate > nWorms) {
                brainToUpdate = 0;
            }

            lastTime = currTime;
            updateBrains = true;
        }

        for(var i = 0; i < nWorms; i++) {

            if(worms[i].noseTouchTimer > 0) {
                worms[i].brain.stimulateNoseTouchNeurons = true;
                worms[i].brain.stimulateFoodSenseNeurons = false;
                worms[i].noseTouchTimer-=1;
            } else {
                worms[i].brain.stimulateNoseTouchNeurons = false;
                worms[i].brain.stimulateFoodSenseNeurons = true;
                noseTouchTimer=0;
            }

            worms[i].sniffTimer++;

            if(updateBrains && i == brainToUpdate) {

                worms[i].brain.update();
                
                var max = 1.0;

                if(worms[i].brain.accumleft > 0.0) {
                    worms[i].wormVelocityX = max;
                } else {
                    worms[i].wormVelocityX = -max;
                }

                if(worms[i].brain.accumright > 0.0) {
                    worms[i].wormVelocityY = max;
                } else {
                    worms[i].wormVelocityY = -max;
                }
                
            }

            worms[i].wormVelocityX *= 0.999;
            worms[i].wormVelocityY *= 0.999;

            wiggleWorm(i, worms[i].wormVelocityX, "x", nSegments-1);
            wiggleWorm(i, worms[i].wormVelocityY, "y", nSegments-1);

            wiggleWorm(i, -worms[i].wormVelocityY*.5, "x", 3);
            wiggleWorm(i, -worms[i].wormVelocityX*.5, "y", 3);

            wiggleWorm(i, worms[i].wormVelocityY, "x", 0);
            wiggleWorm(i, worms[i].wormVelocityX, "y", 0);

            wiggleWorm(i, worms[i].wormVelocityX+worms[i].wormVelocityY, "y", nSegments-1);
        }

    }

    function wiggleWorm(wormID, velocity, axis, segmentIndex) {
        var baseVelocity, rotVelocity;

        if(axis === "x") {
            baseVelocity = new CANNON.Vec3(velocity, 0, 0);
        } else if(axis === "y") {
            baseVelocity = new CANNON.Vec3(0, velocity, 0);
        } else if(axis === "z") {
            baseVelocity = new CANNON.Vec3(0, 0, velocity);
        }

        rotVelocity = rotateVector(baseVelocity, worms[wormID].wormSegments[segmentIndex].quaternion);
        worms[wormID].wormSegments[segmentIndex].velocity.vadd(rotVelocity, worms[wormID].wormSegments[segmentIndex].velocity);
    }

    function updatePhysics(){
        world.step(dt);

        scene.traverse(function(child){
            if (child.isWorm === true){

                child.skeleton.bones[0].position.x = worms[child.wormID].wormSegments[0].position.x;
                child.skeleton.bones[0].position.y = worms[child.wormID].wormSegments[0].position.y;
                child.skeleton.bones[0].position.z = worms[child.wormID].wormSegments[0].position.z;
                
                for(var i = 0; i < nSegments; i++) {
                    child.skeleton.bones[i].position.x = worms[child.wormID].wormSegments[i].position.x;
                    child.skeleton.bones[i].position.y = worms[child.wormID].wormSegments[i].position.y;
                    child.skeleton.bones[i].position.z = worms[child.wormID].wormSegments[i].position.z;
                    child.skeleton.bones[i].quaternion.copy(worms[child.wormID].wormSegments[i].quaternion);
                }
            } else {

                for(var i = 0; i < world.bodies.length; i++) {
                    if(world.bodies[i].objectName != undefined && world.bodies[i].objectName === child.objectName) {
                        child.position.copy(world.bodies[i].position);
                        child.quaternion.copy(world.bodies[i].quaternion);
                        break;
                    }
                }
            }
        });
    }

    function getPhysicsObjectWithName(name) {
        for(var i = 0; i < world.bodies.length; i++) {
            if(world.bodies[i].objectName != undefined && world.bodies[i].objectName === name) {
                return world.bodies[i];
            }
        }
        return undefined;
    }

    function render() {
        renderer.render(scene, camera);
    }

    initThree();
    initCannon();
    initWorm();

    var wallHeight = 500;
    addPhysicsObjectToScene("wall", wallHeight, wallHeight, 0.2,  0, 0, -5,  0);
    addPhysicsObjectToScene("wall2", 0.2, wallHeight, wallHeight,  5, 0, 0,  0);
    addPhysicsObjectToScene("wall3", wallHeight, wallHeight, 0.2,  0, 0, 4,  0);
    addPhysicsObjectToScene("wall4", 0.2, wallHeight, wallHeight,  -4, 0, 0,  0);

    addObjectToScene("room/room.json", "room");

    var groundShape = new CANNON.Plane();
    var groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
    world.addBody(groundBody);

    for(var i = 0; i < nWorms; i++) {
        var ind = i;
        worms[i].wormSegments[nSegments-1].addEventListener("collide",function(e){
            worms[ind].noseTouchTimer = 3;
        });
    }

    animate();

    </script>
</body>
</html>
